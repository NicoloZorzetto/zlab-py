"""
zform_apply applies previously computed zforms transformations
to a DataFrame, using stored parameters.

This module is part of the zlab library by Nicolò Zorzetto.

License
-------
GPL v3
"""

import warnings
try:
    import numpy as np
    import pandas as pd
except ImportError as e:
    msg = (f"Missing dependency: {e.name}. Please install all requirements via "
           "'pip install -r requirements.txt'")
    raise ImportError(msg)

try:
    from rich.console import Console
    from rich.progress import Progress
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None


from zlab.warnings import ZformApplyWarning
from zlab.zform_functions import get_zform_functions, zform_function
from zlab._zform_metadata import extract_metadata


def zform_apply(
    df,
    zforms,
    y=None,
    x=None,
    group_col=None,
    naming="standard",
    verbose=True,
    silence_warnings=False,
):
        """
    Apply one or multiple previously computed zform transformations to a DataFrame.

    Parameters
    ----------
    df : pandas.DataFrame
        Original data to transform.
    zforms : Zforms | pandas.DataFrame
        Fitted transformations generated by `zform()`, or a previously exported file
        re-imported via `Zforms.from_file()`.
        Must include at least the following columns:
        ['y', 'x', 'Best Model', 'Parameters'].
    y : str | list[str] | None, default=None
        Dependent variable(s). If None, applies all available y transformations.
    x : str | list[str] | None, default=None
        Independent variable(s). If None, applies all available x transformations.
    group_col : str | list[str] | None, optional
        Column(s) defining groups used during zform fitting.
        If provided, zform_apply applies group-specific transformations.
    naming : {'standard', 'compact', 'minimal'}, default='standard'
        Naming convention for the transformed columns.
    verbose : bool, default=True
        Whether to print progress and summary messages.
    silence_warnings : bool, default=False
        If True, suppresses all warnings.

    Returns
    -------
    pandas.DataFrame
        The input DataFrame with one or more new columns containing the
        applied zform transformations.

    Notes
    -----
    - When a `Zforms` object is passed, associated metadata is validated before use.
    - Custom transformations stored in metadata are automatically restored
      and registered before application.
    - Column names are dynamically generated depending on the `naming` mode:
        * standard → `x_z_model_for_y`
        * compact  → `x_z_model_y`
        * minimal  → `x_z_model`
    - Grouped transformations are applied per group if `group_col` is provided.

    Examples
    --------
    >>> df_out = zform_apply(df, zf)
    >>> df_out.columns
    Index(['x', 'y', 'x_z_power_for_y'], dtype='object')
    """

    df = df.copy()

    if silence_warnings:
        old_filters = warnings.filters[:]
        warnings.filterwarnings("ignore", category=UserWarning)
    else:
        old_filters = None

    try:
        required_cols = {"y", "x", "Best Model", "Parameters"}
        if not required_cols.issubset(zforms.columns):
            msg = (f"zforms DataFrame must contain columns: {required_cols}")
            raise ValueError(msg)

        # --- Strict metadata validation ---
        metadata = extract_metadata(zforms)
        if not metadata:
            raise ValueError(
                "Missing zform metadata — cannot safely apply transformations.\n"
                "Ensure the zforms file was exported directly from zform() and has not been modified."
            )

        required_meta_keys = {"zlab_version", "created_at", "custom_functions"}
        missing_keys = [k for k in required_meta_keys if k not in metadata]
        if missing_keys:
            raise ValueError(
                f"zforms metadata is incomplete (missing: {', '.join(missing_keys)}). "
                "Refit with a newer version of zform() or check the export."
            )

        # --- Restore custom functions from metadata ---
        custom_funcs = metadata.get("custom_functions", {})

        # Normalize format: list → dict
        if isinstance(custom_funcs, list):
            # assume list of function names, cannot restore source
            if verbose:
                print("⚠️  Metadata contains only function names — skipping code restoration.")
            custom_funcs = {}
        elif not isinstance(custom_funcs, dict):
            raise TypeError(f"Invalid metadata['custom_functions'] type: {type(custom_funcs)}")

        for name, func_info in custom_funcs.items():
            try:
                # Handle both string and dict metadata formats
                source = func_info.get("source") if isinstance(func_info, dict) else str(func_info)
                if not source:
                    raise ValueError(f"No source found for custom function '{name}'")

                source_clean = source.strip()
                SAFE_GLOBALS = {"np": __import__("numpy")}  # safe namespace

                if source_clean.startswith("lambda"):
                    func = eval(source_clean, SAFE_GLOBALS)
                else:
                    namespace = {}
                    exec(source_clean, SAFE_GLOBALS, namespace)
                    func = next(v for v in namespace.values() if callable(v))

                zform_function(name)(func)
                if verbose:
                    print(f"Restored custom function: {name}")

            except Exception as e:
                raise RuntimeError(f"Failed to restore custom function '{name}': {e}") from e



        # --- Get all known transformations (built-in + registered) ---
        TRANSFORMATIONS = get_zform_functions()

        if isinstance(y, str):
            y = [y]
        if isinstance(x, str):
            x = [x]

        available_y = zforms["y"].unique().tolist()
        available_x = zforms["x"].unique().tolist()

        def _filter_valid(vars_list, available, name):
            if vars_list is None:
                return None
            missing = [v for v in vars_list if v not in available]
            if missing and not silence_warnings:
                msg = (f"Skipping {name} not found in zforms: {', '.join(missing)}")
                ZformApplyWarning(msg)
            kept = [v for v in vars_list if v in available]
            if not kept:
                msg = (f"No valid {name} remain after filtering "
                       "(none found in zforms).")
                raise ValueError(msg)
            return kept

        y = _filter_valid(y, available_y, "y")
        x = _filter_valid(x, available_x, "x")

        if y is None and x is None:
            if not silence_warnings:
                msg = ("Neither y nor x specified — "
                       "applying ALL pairwise transformations.\n"
                       "This may create a column for every y~x combination "
                       "found in 'zforms'.")
                ZformApplyWarning(msg)
            subset = zforms.copy()
        elif y is not None and x is None:
            subset = zforms.query("y in @y")
        elif y is None and x is not None:
            subset = zforms.query("x in @x")
        else:
            subset = zforms.query("y in @y and x in @x")

        if subset.empty:
            msg = ("No matching transformations found for the given "
                   "y/x pairs in zforms. Ensure they were fitted by zform().")
            raise ValueError(msg)

        if group_col is not None and "Group" in zforms.columns:
            if isinstance(group_col, str):
                df["_zgroup"] = df[group_col].astype(str)
            elif isinstance(group_col, list):
                df["_zgroup"] = df[group_col].astype(str).agg("_".join, axis=1)
            else:
                msg = ("group_col must be None, str, or list of str.")
                raise ValueError(msg)

            groups = df["_zgroup"].unique()
            if verbose and RICH_AVAILABLE:
                console.print(f"Applying group-specific transformations for {len(groups)} groups...")

            for group_name, gdf in df.groupby("_zgroup"):
                sub_zforms = subset.query("Group == @group_name or Group.isnull()")
                if sub_zforms.empty:
                    continue

                for _, row in sub_zforms.iterrows():
                    yv, xv, model, params_str = row["y"], row["x"], row["Best Model"], row["Parameters"]
                    if model == "N/A" or not isinstance(params_str, str):
                        continue
                    if xv not in df.columns or yv not in df.columns:
                        if not silence_warnings:
                            msg = (f"Skipping ({yv}, {xv}) — missing column in df.")
                            ZformApplyWarning(msg)
                        continue

                    try:
                        params = [float(p.strip()) for p in params_str.split(",")]
                        func = TRANSFORMATIONS.get(model.lower())
                        if func is None:
                            raise ValueError(f"Unknown transformation '{model}' — cannot apply.")
                        if naming == "standard":
                            col_name = f"{xv}_z_{model}_for_{yv}_{group_name}"
                        elif naming == "compact":
                            col_name = f"{xv}_z_{model}_{yv}_{group_name}"
                        elif naming == "minimal":
                            col_name = f"{xv}_z_{model}_{group_name}"
                        else:
                            msg = ("Invalid naming mode. "
                                   "Use 'standard', 'compact', or 'minimal'.")
                            raise ValueError(msg)
                        mask = df["_zgroup"] == group_name
                        df.loc[mask, col_name] = func(df.loc[mask, xv].to_numpy(), *params)
                    except Exception as e:
                        if not silence_warnings:
                            msg = (f"Failed applying {model} to {xv} "
                                   f"~ {yv} (group={group_name}): {e}")
                            ZformApplyWarning(msg)

            df.drop(columns="_zgroup", inplace=True)

        else:
            if verbose and RICH_AVAILABLE:
                console.print(f"Applying {len(subset)} global transformations...")

            for _, row in subset.iterrows():
                yv, xv, model, params_str = row["y"], row["x"], row["Best Model"], row["Parameters"]
                if model == "N/A" or not isinstance(params_str, str):
                    continue
                if xv not in df.columns or yv not in df.columns:
                    if not silence_warnings:
                        msg = (f"Skipping ({yv}, {xv}) — missing column in df.")
                        ZformApplyWarning(msg)
                    continue

                try:
                    params = [float(p.strip()) for p in params_str.split(",")]
                    func = TRANSFORMATIONS.get(model.lower())
                    if func is None:
                        raise ValueError(f"Unknown transformation '{model}' — cannot apply.")
                    if naming == "standard":
                        col_name = f"{xv}_z_{model}_for_{yv}"
                    elif naming == "compact":
                        col_name = f"{xv}_z_{model}_{yv}"
                    elif naming == "minimal":
                        col_name = f"{xv}_z_{model}"
                    else:
                        msg = ("Invalid naming mode. "
                               "Use 'standard', 'compact', or 'minimal'.")
                        raise ValueError(msg)
                    if naming == "minimal" and col_name in df.columns and not silence_warnings:
                        msg = (f"Overwriting existing column '{col_name}' "
                               "(multiple y for same x).")
                        ZformApplyWarning(msg)
                    df[col_name] = func(df[xv].to_numpy(), *params)
                except Exception as e:
                    if not silence_warnings:
                        msg = (f"Failed applying {model} to {xv} ~ {yv}: {e}")
                        ZformApplyWarning(msg)

        return df

    finally:
        if silence_warnings and old_filters is not None:
            warnings.filters = old_filters
