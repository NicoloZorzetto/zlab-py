"""
zform_apply applies previously computed zforms transformations
to a DataFrame, using stored parameters.

This module is part of the zlab library by Nicolò Zorzetto.

License
-------
GPL v3
"""

import warnings
try:
    import numpy as np
    import pandas as pd
except ImportError as e:
    msg = (f"Missing dependency: {e.name}. Please install all requirements via "
           "'pip install -r requirements.txt'")
    raise ImportError(msg)

try:
    from rich.console import Console
    from rich.progress import Progress
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None


from zlab.warnings import ZformApplyWarning
from zlab.zform_functions import get_zform_functions, zform_function
from zlab._zform_metadata import extract_metadata


def _zform_apply(
    df,
    zforms,
    y=None,
    x=None,
    group_col=None,
    naming="standard",
    verbose=True,
    silence_warnings=False,
):
    """
    Apply one or multiple previously computed zform transformations to a DataFrame.

    Parameters
    ----------
    df : pandas.DataFrame
        Original data to transform.
    zforms : Zforms | pandas.DataFrame
        Fitted transformations generated by `zform()`, or a previously exported file
        re-imported via `Zforms.from_file()`.
        Must include at least the following columns:
        ['y', 'x', 'Best Model', 'Parameters'].
    y : str | list[str] | None, default=None
        Dependent variable(s). If None, applies all available y transformations.
    x : str | list[str] | None, default=None
        Independent variable(s). If None, applies all available x transformations.
    group_col : str | list[str] | None, optional
        Column(s) defining groups used during zform fitting.
        If provided, zform_apply applies group-specific transformations.
    naming : {'standard', 'compact', 'minimal'}, default='standard'
        Naming convention for the transformed columns.
    verbose : bool, default=True
        Whether to print progress and summary messages.
    silence_warnings : bool, default=False
        If True, suppresses all warnings.

    Returns
    -------
    pandas.DataFrame
        The input DataFrame with one or more new columns containing the
        applied zform transformations.

    Notes
    -----
    - When a `Zforms` object is passed, associated metadata is validated before use.
    - Custom transformations stored in metadata are automatically restored
      and registered before application.
    - Column names are dynamically generated depending on the `naming` mode:
        - standard → `x_z_model_for_y`
        - compact  → `x_z_model_y`
        - minimal  → `x_z_model`
    - Grouped transformations are applied per group if `group_col` is provided.
      Group names are appended for non-minimal naming.

    Examples
    --------
    >>> df_out = zform_apply(df, zf)
    >>> df_out.columns
    Index(['x', 'y', 'x_z_power_for_y'], dtype='object')
    """
    df = df.copy()

    if silence_warnings:
        old_filters = warnings.filters[:]
        warnings.filterwarnings("ignore", category=UserWarning)
    else:
        old_filters = None

    try:
        required_cols = {"y", "x", "Best Model", "Parameters"}
        if not required_cols.issubset(zforms.columns):
            msg = (f"zforms DataFrame must contain columns: {required_cols}")
            raise ValueError(msg)

        # --- Strict metadata validation ---
        metadata = extract_metadata(zforms)
        if not metadata:
            raise ValueError(
                "Missing zform metadata — cannot safely apply transformations.\n"
                "Ensure the zforms file was exported directly from zform() and has not been modified."
            )

        required_meta_keys = {"zlab_version", "created_at", "custom_functions"}
        missing_keys = [k for k in required_meta_keys if k not in metadata]
        if missing_keys:
            raise ValueError(
                f"zforms metadata is incomplete (missing: {', '.join(missing_keys)}). "
                "Refit with a newer version of zform() or check the export."
            )

               # --- Auto-restore grouping if zforms were fitted by group ---
        if group_col is None and "Group" in zforms.columns:
            config = metadata.get("config", {})
            auto_group_col = config.get("group_col", None)
            if auto_group_col is not None:
                group_col = auto_group_col
                if not silence_warnings:
                    group_desc = (
                        ", ".join(auto_group_col)
                        if isinstance(auto_group_col, (list, tuple))
                        else str(auto_group_col)
                    )
                    ZformApplyWarning(f"No group_col provided — defaulting to original grouping: {group_desc}")

        # --- Restore custom functions from metadata ---
        custom_funcs = metadata.get("custom_functions", {})

        if isinstance(custom_funcs, list):
            if verbose:
                print("Metadata contains only function names — skipping code restoration.")
            custom_funcs = {}
        elif not isinstance(custom_funcs, dict):
            raise TypeError(f"Invalid metadata['custom_functions'] type: {type(custom_funcs)}")

        for name, func_info in custom_funcs.items():
            try:
                source = func_info.get("source") if isinstance(func_info, dict) else str(func_info)
                if not source:
                    raise ValueError(f"No source found for custom function '{name}'")
                source_clean = source.strip()
                SAFE_GLOBALS = {"np": __import__("numpy")}
                if source_clean.startswith("lambda"):
                    func = eval(source_clean, SAFE_GLOBALS)
                else:
                    namespace = {}
                    exec(source_clean, SAFE_GLOBALS, namespace)
                    func = next(v for v in namespace.values() if callable(v))
                zform_function(name)(func)
                if verbose:
                    print(f"Restored custom function: {name}")
            except Exception as e:
                raise RuntimeError(f"Failed to restore custom function '{name}': {e}") from e

        TRANSFORMATIONS = get_zform_functions()
        TRANSFORMATIONS = {k.lower(): v for k, v in TRANSFORMATIONS.items()}

        if isinstance(y, str):
            y = [y]
        if isinstance(x, str):
            x = [x]

        available_y = zforms["y"].unique().tolist()
        available_x = zforms["x"].unique().tolist()

        def _filter_valid(vars_list, available, name):
            if vars_list is None:
                return None
            missing = [v for v in vars_list if v not in available]
            if missing and not silence_warnings:
                msg = (f"Skipping {name} not found in zforms: {', '.join(missing)}")
                ZformApplyWarning(msg)
            kept = [v for v in vars_list if v in available]
            if not kept:
                raise ValueError(f"No valid {name} remain after filtering (none found in zforms).")
            return kept

        y = _filter_valid(y, available_y, "y")
        x = _filter_valid(x, available_x, "x")

        if y is None and x is None:
            if not silence_warnings:
                msg = (
                    "Neither y nor x specified — applying ALL pairwise transformations.\n"
                    "This may create a column for every y~x combination found in 'zforms'."
                )
                ZformApplyWarning(msg)
            subset = zforms.copy()
        elif y is not None and x is None:
            subset = zforms.query("y in @y")
        elif y is None and x is not None:
            subset = zforms.query("x in @x")
        else:
            subset = zforms.query("y in @y and x in @x")

        if subset.empty:
            raise ValueError("No matching transformations found for the given y/x pairs in zforms.")

        # --- Helper for naming convention ---
        def _make_col_name(xv, yv, model, group_name=None):
            """Return the transformed column name based on naming mode and group."""
            group_suffix = ""
            if group_name and naming != "minimal":
                if isinstance(group_name, (list, tuple)):
                    group_suffix = "_" + "_".join(str(g) for g in group_name)
                else:
                    group_suffix = f"_{group_name}"

            if naming == "standard":
                return f"{xv}_z_{model}_for_{yv}{group_suffix}"
            elif naming == "compact":
                return f"{xv}_z_{model}_{yv}{group_suffix}"
            elif naming == "minimal":
                return f"{xv}_z_{model}"
            else:
                raise ValueError("Invalid naming mode — use 'standard', 'compact', or 'minimal'.")
            
        # --- Apply transformations ---
        if group_col is not None and "Group" in zforms.columns:
            if isinstance(group_col, str):
                df["_zgroup"] = df[group_col].astype(str)
            elif isinstance(group_col, list):
                df["_zgroup"] = df[group_col].astype(str).agg("_".join, axis=1)
            else:
                raise ValueError("group_col must be None, str, or list of str.")

            groups = df["_zgroup"].unique()
            if verbose and RICH_AVAILABLE:
                console.print(f"Applying group-specific transformations for {len(groups)} groups...")

            for group_name, gdf in df.groupby("_zgroup"):
                sub_zforms = subset.query("Group == @group_name or Group.isnull()")
                if sub_zforms.empty:
                    continue

                for _, row in sub_zforms.iterrows():
                    yv, xv, model, params_str = row["y"], row["x"], row["Best Model"], row["Parameters"]
                    if model == "N/A" or not isinstance(params_str, str):
                        continue
                    if xv not in df.columns or yv not in df.columns:
                        if not silence_warnings:
                            ZformApplyWarning(f"Skipping ({yv}, {xv}) — missing column in df.")
                        continue
                    try:
                        params = [float(p.strip()) for p in params_str.split(",")]
                        func = TRANSFORMATIONS.get(model.lower())
                        if func is None:
                            raise ValueError(f"Unknown transformation '{model}' — could not apply.")
                        col_name = _make_col_name(xv, yv, model, group_name)
                        mask = df["_zgroup"] == group_name
                        df.loc[mask, col_name] = func(df.loc[mask, xv].to_numpy(), *params)
                    except Exception as e:
                        if not silence_warnings:
                            ZformApplyWarning(f"Failed applying {model} to {xv} ~ {yv} (group={group_name}): {e}")

            df.drop(columns="_zgroup", inplace=True)

        else:
            if verbose and RICH_AVAILABLE:
                console.print(f"Applying {len(subset)} global transformations...")

            for _, row in subset.iterrows():
                yv, xv, model, params_str = row["y"], row["x"], row["Best Model"], row["Parameters"]
                if model == "N/A" or not isinstance(params_str, str):
                    continue
                if xv not in df.columns or yv not in df.columns:
                    if not silence_warnings:
                        ZformApplyWarning(f"Skipping ({yv}, {xv}) — missing column in df.")
                    continue
                try:
                    params = [float(p.strip()) for p in params_str.split(",")]
                    func = TRANSFORMATIONS.get(model.lower())
                    if func is None:
                        raise ValueError(f"Unknown transformation '{model}' — cannot apply.")
                    col_name = _make_col_name(xv, yv, model)
                    if naming == "minimal" and col_name in df.columns and not silence_warnings:
                        msg = (f"Overwriting existing column '{col_name}' (multiple y for same x).")
                        ZformApplyWarning(msg)
                    # Explicit overwrite — no auto _1/_2 suffixing
                    df[col_name] = func(df[xv].to_numpy(), *params)

                except Exception as e:
                    if not silence_warnings:
                        ZformApplyWarning(f"Failed applying {model} to {xv} ~ {yv}: {e}")

        return df

    finally:
        if silence_warnings and old_filters is not None:
            warnings.filters = old_filters
